문제 조건 잘 확인하자... 슬프다
m <= n 이라는 조건이
있었는데... 이걸 확인을 안 해서
필요도 없는 테스트 케이스를 추가해서
난이도를 올려 풀고 있나... 하 진짜..
슬프네...


<아이들과 선물 상자>
상훈이 N개의 선물상자
각 상자 담겨있는 선물 개수 적혀있음
선물을 받을 아이들 M명
아이들 서로 다른 번호 1~M까지 가짐

1번 아이부터 M번 아이까지 
한 번에 한 명씩, 
현재 선물이 가장 많이 담겨있는 상자에서
각자 원하는 만큼 선물을 가져간다

상자에 자신이 원하는 것보다
적은 개수의 선물이 있다면, 실망한다

목적
한 명이라도 실망하지 않고 모두가 선물을 가져갈 수 있는가


선물 상자의 수
n(1 ≤ n ≤ 100,000)

아이들 수
m(1 ≤ m ≤ 100,000)

각 선물 상자에 들어있는 선물의 개수
ci(1 ≤ ci ≤ 100,000)

아이 한 명당 원하는 선물의 개수
wi(1 ≤ wi ≤ 100,000)

모든 아이들이 실망하지 않고 
선물을 가져갈 수 있으면 1을
그렇지 않으면 0을


아아아 중복 입력을 생각을 못했어 나는 빡대가리야....
bool 배열 int 배열로 바꿔야해...그러면
공간 복잡도가
어떻게되지?
100,000행, 3열
300,000 * 4byte = 1,200,000 byte = 1.2MB  ok
heap*2 
괜츈해 널널해 1024 MB 까지 널널해 걱정하지마 
공간복잡도는
빅오로
5n ==> n 인듯? 
heap 자세하게 따지지 말고
다 단일 배열로 취급해서  

ㅡㅡㅡㅡㅡ idea ㅡㅡㅡㅡㅡ
maxheap을 사용한다 X 2 (for ci, for wi)

입력받는다

bool visit_box[][][]를 이용
0열 입력이 ci나 wi에서 한 번이라도 있었나
1열 입력이 ci에서 있었나
2열 입력이 wi에서 있었나

0열이 true이고
1열 2열이 서로 다를 때, 
시간복잡도를 생각해서 큰 값부터 
각각 maxheap에 원소를 넣자!

box = ci top, ci pop
needs = wi top, wi pop

box < needs 불가능

box == needs 가능

box > needs 가능
힙에 push(box - needs)

ㅡㅡㅡㅡㅡ case ㅡㅡㅡㅡㅡ
10 8 6 4 2
9 6 4 4 3 2 1 1

같은 것만 먼저 뺀다?

10 8
9 4 3 1 1

8 1
4 3 1 1 1

ㅡㅡㅡㅡㅡ 시간 복잡도 ㅡㅡㅡㅡㅡ
입력 
n행 3열의 2차원 bool 배열
3n

maxheap에 원소 추가 (2개)
2n long n

box maxheap개수만큼 push가 생길거임
최악의 경우
n log n

정답 출력
상수시간

대략
3n + 2n log n + n long n
3n + 3n log n
=> 약 5,282,892번의 계산이 있을 거 같은데?
20,000,000 안 넘으니까 괜츈할듯?

ㅡㅡㅡㅡㅡ 실패 ㅡㅡㅡㅡㅡ
5 8
10 8 6 4 2
9 6 4 4 3 2 1 1

8 6 4 2 1
6 4 4 3 2 1 1

6 4 2 2 1
4 4 3 2 2 1 1

4 2 2 2 2 1
4 3 2 2 1 1

2 2 2 2 1
3 2 2 1 1

2 2 2 2 1
3 2 2 1 1
